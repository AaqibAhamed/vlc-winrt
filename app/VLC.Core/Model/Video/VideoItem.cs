/**********************************************************************
 * VLC for WinRT
 **********************************************************************
 * Copyright © 2013-2014 VideoLAN and Authors
 *
 * Licensed under GPLv2+ and MPLv2
 * Refer to COPYING file of the official project for license
 **********************************************************************/

using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using Windows.Storage;
using Windows.UI.Core;
using SQLite;
using VLC.Commands.VideoLibrary;
using VLC.Utils;
using VLC.ViewModels;
using Windows.Storage.AccessCache;
using libVLCX;
using Windows.UI.Xaml.Media.Imaging;
using VLC.Helpers;

namespace VLC.Model.Video
{
    public class VideoItem : BindableBase, IMediaItem
    {
        #region private props
        private string _filePath;
        private string _token;
        private string _name = string.Empty;
        private string _subtitle = string.Empty;
        private bool _favorite;
        private TimeSpan _duration;
        private int _timeWatchedSeconds;
        private StorageFile _file;
        private DateTime _lastWatched;

        private BitmapImage _videoImage;
        private LoadingState _videosImageLoadingState = LoadingState.NotLoaded;

        #region tvshows props // TVShows related // Todo create a class ShowEpisodeItem that inherits from VideoItem
        private string _showTitle;
        private int _season = -1;
        private int _episode;
        #endregion

        #endregion

        #region private fields

        #endregion

        #region public props
        #region tvshows related
        public bool IsTvShow { get; set; }

        public string ShowTitle
        {
            get { return _showTitle; }
            set { SetProperty(ref _showTitle, value); }
        }

        public int Season
        {
            get { return _season; }
            private set { SetProperty(ref _season, value); }
        }

        public int Episode
        {
            get { return _episode; }
            private set { SetProperty(ref _episode, value); }
        }
        #endregion

        [PrimaryKey, AutoIncrement, Column("_id")]
        public int Id { get; set; }
        public bool IsAvailable { get;
            set; }
        public string Name
        {
            get { return _name; }
            set { SetProperty(ref _name, value); }
        }

        public string Type => System.IO.Path.GetExtension(Path);

        public uint Width { get; set; }
        public uint Height { get; set; }

        public bool Favorite
        {
            get { return _favorite; }
            set { SetProperty(ref _favorite, value); }
        }
        public TimeSpan Duration
        {
            get { return _duration; }
            set { SetProperty(ref _duration, value); }
        }

        public DateTime LastWatched
        {
            get { return _lastWatched; }
            set { SetProperty(ref _lastWatched, value); }
        }

        // The thumbnail generated by VLC.
        private bool _hasThumbnail;
        public Boolean HasThumbnail {
            get { return _hasThumbnail; }
            set
            {
                _hasThumbnail = value;
                OnPropertyChanged(nameof(VideoImage));
            }
        }

        // The picture obtained through a metadata service.
        private bool _hasMoviePicture;
        public Boolean HasMoviePicture {
            get { return _hasMoviePicture; }
            set
            {
                _hasMoviePicture = value;
                OnPropertyChanged(nameof(VideoImage));
            }
        }

        public bool IsSubtitlePreLoaded { get; set; }
        

        public Boolean IsCameraRoll { get; set; }
        
        public int TimeWatchedSeconds
        {
            get
            {
                return _timeWatchedSeconds;
            }
            set
            {
                SetProperty(ref _timeWatchedSeconds, value);
                OnPropertyChanged(nameof(TimeWatched));
                OnPropertyChanged(nameof(HasBeenSeen));
            }
        }
        
        [Ignore]
        public BitmapImage VideoImage
        {
            get
            {
                if(_videoImage == null)
                    InitializeVideoImage();
                return _videoImage;
            }
            private set { SetProperty(ref _videoImage, value); }
        }

        public void InitializeVideoImage()
        {
            if (_videoImage != null) return;

            if (HasThumbnail || HasMoviePicture)
            {
                _videosImageLoadingState = LoadingState.Loaded;

                Task.Run(async () =>
                {
                    await DispatchHelper.InvokeInUIThreadHighPriority(async () =>
                     {
                         VideoImage = await GetBitmap();
                     });
                });
            }
            else if (_videosImageLoadingState == LoadingState.NotLoaded)
            {
                _videosImageLoadingState = LoadingState.Loading;
                Locator.MediaLibrary.GenerateVideoThumbnailAsync(this);
            }
        }

        [Ignore]
        public string PictureUri
        {
            get
            {
                // Prefer movie pictures downloaded from the web as thumbnails
                if (HasMoviePicture)
                {
                    return $"{Strings.MoviePicFolderPath}/{Id}.jpg";
                }
                else if (HasThumbnail)
                {
                    return $"{Strings.VideoThumbsFolderPath}/{Id}.jpg";
                }
                return string.Empty;
            }
        }

        public async Task<bool> VideoThumbFileExist()
        {
            return (await TryGetVideoThumbFile()) != null;
        }

        async Task<BitmapImage> GetBitmap()
        {
            BitmapImage bitmap = null;
            try
            {
                var file = await TryGetVideoThumbFile();
                if (file == null) return null;

                var stream = await file.OpenReadAsync();
                if (stream == null) return null;
                bitmap = new BitmapImage();
                await bitmap.SetSourceAsync(stream);
            }
            catch (Exception e)
            {
                LogHelper.Log(e.Message);
            }

            return bitmap;
        }

        public async Task DeleteVideoThumbFile()
        {
            var thumbFile = await TryGetVideoThumbFile();
            if (thumbFile != null)
                await thumbFile.DeleteAsync().AsTask().ConfigureAwait(false);
        }

        private async Task<StorageFile> TryGetVideoThumbFile()
        {
            StorageFile ret = null;
            try
            {
                var subFolder = await ApplicationData.Current.LocalFolder.GetFolderAsync("videoThumbs");
                if (subFolder != null)
                    ret = (StorageFile) await subFolder.GetItemAsync($"{Id}.jpg");
                return ret;
            }
            catch (FileNotFoundException ex)
            {
                Debug.WriteLine(ex);
            }
            catch (UnauthorizedAccessException ex)
            {
                Debug.WriteLine(ex);
            }
            catch (ArgumentException ex)
            {
                Debug.WriteLine(ex);
            }
            return null;
        }

        [Ignore]
        public string SubtitleUri
        {
            get
            {
                if (IsSubtitlePreLoaded)
                {
                    return $"{Strings.MovieSubFolderPath}/{Id}{SubtitleExtension}";
                }
                return string.Empty;
            }
        }

        public string SubtitleExtension { get; set; }

        [Ignore]
        public StorageFile File
        {
            get { return _file; }
            private set
            {
                SetProperty(ref _file, value);
            }
        }

        [Ignore]
        public String Token
        {
            get { return _token; }
            set { SetProperty(ref _token, value); }
        }

        [Unique]
        public string Path
        {
            get { return _filePath; }
            set { SetProperty(ref _filePath, value); }
        }

        [Ignore]
        public char AlphaKey => Name.ToUpper()[0];

        [Ignore]
        public TimeSpan TimeWatched
        {
            get { return TimeSpan.FromSeconds(_timeWatchedSeconds); }
        }

        [Ignore]
        public bool HasBeenSeen
        {
            get
            {
                return TimeWatched.Seconds > 0 && Duration.Seconds > 30 && ((double)TimeWatched.Seconds / Duration.Seconds) < 0.98;
            }
        }

        [Ignore]
        public FavoriteVideoCommand FavoriteVideo { get; } = new FavoriteVideoCommand();

        [Ignore]
        public Media VlcMedia { get; set; }

        #endregion

        #region public fields

        #endregion

        #region constructors
        public VideoItem()
        {
        }
        
        public VideoItem(string name, string path, TimeSpan duration, uint width, uint height, string showTitle, int season, int episode)
        {
            this._name = name;
            this._filePath = path;
            this._duration = duration;
            this._showTitle = showTitle;
            this._season = season;
            this._episode = episode;
            this.Height = height;
            this.Width = width;

            IsTvShow = !string.IsNullOrEmpty(showTitle) && season >= 0 && episode >= 0;
        }

        #endregion

        #region methods
        public Tuple<FromType, string> GetMrlAndFromType(bool preferToken)
        {
            if (!string.IsNullOrEmpty(_token))
            {
                // Using an already created token
                return new Tuple<FromType, string>(FromType.FromLocation, "winrt://" + _token);
            }
            if (File != null && (string.IsNullOrEmpty(Path) || preferToken))
            {
                // Using a Token
                // FromLocation : 1
                return new Tuple<FromType, string>(FromType.FromLocation, "winrt://" + StorageApplicationPermissions.FutureAccessList.Add(File));
            }
            if (!string.IsNullOrEmpty(Path))
                return new Tuple<FromType, string>(FromType.FromPath, Path);
            return null;
        }

        public bool IsCurrentPlaying
        {
            get
            {
                return this == Locator.PlaybackService.CurrentPlaybackMedia;
            }
        }

        public async Task<bool> LoadFileFromPath()
        {
            try
            {
                if (File == null)
                {
                    var f = await StorageFile.GetFileFromPathAsync(Path);
                    await DispatchHelper.InvokeInUIThread(CoreDispatcherPriority.Normal, () => File = f);
                }
            }
            catch (Exception)
            {
                return false;
            }
            return true;
        }
        #endregion
    }
}
